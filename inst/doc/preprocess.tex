\section{Preprocessing via Matching}
\label{sec:matching}

\subsection{Quick Overview}

The main command \texttt{matchit()} implements the matching
procedures.  A general syntax is:
\begin{verbatim}
> m.out <- matchit(treat ~ x1 + x2, data = mydata)
\end{verbatim}
where {\tt treat} is the dichotomous treatment variable, and {\tt x1}
and {\tt x2} are pre-treatment covariates, all of which are contained
in the data frame {\tt mydata}.  The dependent variable will normally
be part of \texttt{mydata} but is never used by \MatchIt\ or included
the formula.  This command creates the \MatchIt\ object called
\texttt{m.out}.  Name the output object to see a quick summary of the
results:
\begin{verbatim}
> m.out
\end{verbatim}

\subsection{Examples}

To run any of the examples below, you first must load the library and
and data:
\begin{verbatim}
> library(MatchIt)
> data(lalonde)
\end{verbatim}

Our example data set is from the job training program analyzed in
\citet{lalonde86} and \citet{DehWah99}. \MatchIt\ includes a subsample
of the original data consisting of the National Supported Work
Demonstration (NSW) treated group and the comparison sample from the
Population Survey of Income Dynamics (PSID).\footnote{This data set,
  \texttt{lalonde}, was created using NSWRE74$\_$TREATED.TXT and
  CPS3$\_$CONTROLS.TXT from
  http://www.columbia.edu/$\sim$rd247/nswdata.}  The variables in this
data set include participation in the job training program
(\texttt{treat}, which is equal to 1 if participated in the program,
and 0 otherwise), age ({\tt age}), years of education ({\tt educ}),
race (\texttt{black} which is equal to 1 if black, and 0 otherwise;
\texttt{hispan} which is equal to 1 if hispanic, and 0 otherwise),
marital status (\texttt{married}, which is equal to 1 if married, 0
otherwise), high school degree (\texttt{nodegree}, which is equal to 1
if no degree, 0 otherwise), 1974 real earnings (\texttt{re74}), 1975
real earnings (\texttt{re75}), and 1978 real earnings (\texttt{re78}).

\subsubsection{Exact Matching}
\label{subsubsec:exact}

The simplest version of matching is exact.  This technique matches
\emph{each} treated unit to \emph{all} possible control units with
exactly the same value on all the covariates, forming subclasses such
that within each subclass all units (treatment and control) have the
same covariate values.  Exact matching is implemented in \MatchIt\ 
using \texttt{method = "exact"}.  Exact matching will be done on all
covariates included on the right-hand side of the \texttt{formula}
specified in the \MatchIt\ call.  There are no additional options for
exact matching.  Exact restrictions on a subset of covariates can also
be specified in nearest neighbor matching (see
Section~\ref{subsubsec:nearest}).  The following example script can be
run by typing {\tt demo(exact)} at the R prompt,
\begin{verbatim}
> m.out <- matchit(treat ~ educ + black + hispan, data = lalonde, 
                   method = "exact")
\end{verbatim}

\subsubsection{Subclassification}
\label{subsubsec:subclass}

When there are many covariates on which matches are desired (or some
covariates can take a large number of values), finding sufficient
exact matches will often be impossible.  The goal of subclassification
is to form subclasses, such that in each the distribution (rather than
the exact values) of covariates for the treated and control groups are
are as similar as possible.  Various subclassification schemes exist,
including the one based on a scalar distance measure such as the
propensity score estimated using the \texttt{distance} option (see
Section~\ref{subsubsec:inputs-all}).  Subclassification is implemented
in \MatchIt\ using \texttt{method = "subclass"}.

The following example script can be run by typing {\tt demo(subclass)}
at the R prompt,
\begin{verbatim}
> m.out <- matchit(treat ~ re74 + re75 + educ + black + hispan + age, 
                   data = lalonde, method = "subclass")
\end{verbatim}
The above syntax forms 6 subclasses, which is the default number
of subclasses, based on a distance measure estimated using logistic
regression.  By default, each subclass will have approximately the
same number of treated units.

Subclassification may also be used in conjunction with nearest
neighbor matching described below, by leaving the default of
\texttt{method = "nearest"} but adding the option \texttt{subclass}.
When you choose this command, \MatchIt\ matches in the same way, but
after the nearest neighbor matches are chosen it places them into
subclasses, and adds a variable to the output object with the subclass
numbers.

\subsubsection{Nearest Neighbor Matching}
\label{subsubsec:nearest}

Nearest neighbor matching selects the $r$ best control matches for
each individual in the treatment group (excluding those discarded
using the \texttt{discard}) option (by default, $r=1$).  The matching
is done using a distance measure specified by the {\tt distance}
option.  Matches are chosen for each treated unit one at a time, and
at each matching step we choose the control unit that is not yet
matched but is closest to the treated unit on the distance measure.

Nearest neighbor matching is implemented in \MatchIt\ using the
\texttt{method = "nearest"} option.  The following example script can
be run by typing {\tt demo(nearest)}:
\begin{verbatim}
> m.out <- matchit(treat ~ re74 + re75 + educ + black + hispan + age, 
                   data = lalonde, method = "nearest")
\end{verbatim}

\subsubsection{Optimal Matching}
\label{subsubsec:optimal}

The default nearest neighbor matching method in \MatchIt\ is
``greedy'' matching, where the closest control match for each treated
unit is chosen one at a time, without trying to minimize a global
distance measure.  In contrast, ``optimal'' matching, finds the
matched samples with the smallest average absolute distance across all
the matched pairs.  \citet{GuRos93} find that greedy and optimal
matching generally choose the same sets of controls for the overall
matched samples, but that optimal matching does a better job of
minimizing the distance within each pair.  In addition, optimal
matching can be helpful when there are not many appropriate control
matches for the treated units.

Optimal matching is performed with \MatchIt\ by setting \texttt{method
  = "optimal"}.  We use an add-on package called \texttt{optmatch}
\citep{Hansen04}, which will be automatically installed when needed.
The following example can also be run by typing {\tt demo(optimal)} at
the R prompt.  We conduct optimal ratio matching based on the
propensity score from the logistic regression.
\begin{verbatim}
> m.out <- matchit(treat ~ re74 + re75 + age + educ, data = lalonde, 
                   method = "optimal", ratio = 2)
\end{verbatim}

\subsubsection{Full Matching}
\label{subsubsec:full}

Full matching is a a particular type of subclassification that uses
all treated and control units \citep{Rosenbaum02, Hansen04}.  A fully
matched sample is composed of matched sets, where each matched set
contains one treated unit and one or more controls (or one control
unit and one or more treated units).  The only units not placed into a
subclass will be those discarded (if a \texttt{discard} option was
specified) because they are outside the range of common support.  Full
matching is optimal in terms of minimizing a weighted average of the
estimated distance measure between each treated subject and each
control subject within each subclass.

Full matching can be performed with \MatchIt\ by setting
\texttt{method = "full"}.  We use an add-on package called
\texttt{optmatch} \citep{Hansen04}, which will be automatically
installed when needed.  The following example with full matching (using
the propensity score based on logistic regression) can also be run by
typing {\tt demo(full)} at the R prompt:
\begin{verbatim}
> m.out <- matchit(treat ~ age + educ + black + hispan + married +
                   nodegree + re74 + re75, data = lalonde, method = "full")
\end{verbatim}

\subsubsection{Genetic Matching}
\label{subsub:genetic}

Genetic matching is a method that automates the process of finding an
optimal balance \citep{DiaSek05}. The idea is to use a genetic search
algorithm and to find a set of weights for each covariate such that
the optimal balance is achieved after matching.  As it is currently
implemented, matching is done with replacement using the matching
method of \citet{AbaImb04} and balance is determined by two univariate
tests: paired t-tests for dichotomous variables and a
Kolmogorov-Smirnov test for multinomial and continuous variables.

Genetic matching can be performed with \MatchIt\ by setting
\texttt{method = "genetic"}.  We use an add-on package called
\texttt{Matching} \citep{Sekhon04}, which will be automatically
installed when needed.  The following example of genetic matching
(using the estimated propensity score based on logistic regression as
one of the covariates) can also be run by typing {\tt demo(genetic)}:
\begin{verbatim}
> m.out <- matchit(treat ~ age + educ + black + hispan + married + nodegree + 
                   re74 + re75, data = lalonde, method = "genetic")
\end{verbatim}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "matchit"
%%% End: 
